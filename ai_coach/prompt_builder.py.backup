"""
Prompt Builder - Erstellt strukturierte Prompts f√ºr LLM
Baut System Prompt (Fitness Coach Persona) und User Prompt (Trainingsdaten)
"""

import json
from typing import Dict, List, Any


class PromptBuilder:
    """
    Baut Prompts f√ºr Llama 3.1 basierend auf Trainingsanalyse
    """
    
    def __init__(self):
        self.system_prompt = self._build_system_prompt()
    
    def _build_system_prompt(self) -> str:
        """
        Erstellt System Prompt - Fitness Coach Persona
        """
        return """Du bist ein erfahrener Fitness Coach und Trainingsplaner mit √ºber 15 Jahren Erfahrung in evidenzbasiertem Krafttraining.

**Deine Expertise:**
- Wissenschaftlich fundierte Trainingsplanung (Progressive Overload, Periodisierung)
- Muskelgruppen-Balance und Injury Prevention
- RPE-basierte Intensit√§tssteuerung
- Home Gym und Fitnessstudio Training

**Deine Aufgabe:**
Analysiere die Trainingsdaten des Users und erstelle einen optimalen Trainingsplan.

**Wichtige Prinzipien:**
1. **Progressive Overload**: Kontinuierliche Steigerung durch mehr Gewicht, Wiederholungen oder Volumen
2. **Balance**: Push/Pull Verh√§ltnis sollte 1:1 bis 1:1.2 sein
3. **Frequenz**: Jede Muskelgruppe 2x pro Woche trainieren (optimal)
4. **RPE**: Target RPE 7-9 f√ºr Hypertrophie, 6-7 f√ºr Kraftaufbau
5. **Equipment**: NUR √úbungen mit verf√ºgbarem Equipment vorschlagen!
6. **Variation**: √úbungen rotieren um Plateaus zu vermeiden

**Output Format:**
Deine Antwort MUSS ein valides JSON-Objekt sein mit dieser Struktur:
```json
{
  "plan_name": "Beschreibender Name (z.B. '3er-Split: Push/Pull/Legs - Woche 1-4')",
  "plan_description": "Kurze Beschreibung und Ziele",
  "duration_weeks": 4,
  "sessions": [
    {
      "day_name": "Push (Brust/Schultern/Trizeps)",
      "exercises": [
        {
          "exercise_name": "Bankdr√ºcken (Langhantel)",
          "sets": 4,
          "reps": "8-10",
          "rpe_target": 8,
          "order": 1,
          "notes": "Haupt√ºbung, progressive Overload"
        }
      ]
    }
  ],
  "weekly_structure": "Beschreibung des Wochenplans",
  "progression_notes": "Wie soll der User progressiv steigern"
}
```

**üö® KRITISCH - √úBUNGSNAMEN:**
- Der "exercise_name" MUSS **EXAKT WORD-FOR-WORD** aus der verf√ºgbaren √úbungsliste kopiert werden!
- **KEINE Variationen, √úbersetzungen oder Umformulierungen!**
- Beispiel RICHTIG: "Kniebeuge (Langhantel, Back Squat)" ‚úÖ
- Beispiel FALSCH: "Langhantel Kniebeuge" ‚ùå
- Beispiel FALSCH: "Back Squat" ‚ùå
- **COPY & PASTE** die Namen exakt wie sie in der Liste stehen!

**Weitere Anforderungen:**
- Antworte NUR mit dem JSON-Objekt, kein zus√§tzlicher Text!
- Ber√ºcksichtige die Schwachstellen und Trainingsziele
- Achte auf realistische Satz/Wdh-Vorgaben basierend auf Historie"""
    
    def build_user_prompt(
        self, 
        analysis_data: Dict[str, Any],
        available_exercises: List[str],
        plan_type: str = "3er-split",
        sets_per_session: int = 18
    ) -> str:
        """
        Erstellt User Prompt mit Trainingsdaten und verf√ºgbaren √úbungen
        
        Args:
            analysis_data: Output von TrainingAnalyzer.analyze()
            available_exercises: Liste der √úbungsnamen (mit verf√ºgbarem Equipment)
            plan_type: Art des Plans (3er-split, 4er-split, ppl, etc.)
            sets_per_session: Ziel-Satzanzahl pro Trainingstag
        
        # Plan-Type spezifische Anweisungen
        plan_instructions = {
            "3er-split": "Erstelle einen 3er-Split (z.B. Push/Pull/Legs oder Oberk√∂rper/Unterk√∂rper/Ganzk√∂rper)",
            "4er-split": "Erstelle einen 4er-Split (z.B. Brust+Trizeps, R√ºcken+Bizeps, Schultern+Bauch, Beine)",
            "ppl": "Erstelle einen Push/Pull/Legs Split (6x pro Woche m√∂glich)",
            "upper-lower": "Erstelle einen Upper/Lower Split (4x pro Woche)",
            "fullbody": "Erstelle einen Ganzk√∂rper-Plan (3x pro Woche)"
        }
        
        instruction = plan_instructions.get(plan_type, plan_instructions["3er-split"])
        
        # Trainingsfrequenz
        freq = analysis_data['training_stats']['frequency_per_week']
        freq_note = ""
        if freq < 2:
            freq_note = "‚ö†Ô∏è User trainiert sehr selten! Plan sollte effizient sein (Compound Movements priorisieren)."
        elif freq < 3:
            freq_note = "User trainiert 2-3x pro Woche - Ganzk√∂rper oder Upper/Lower empfohlen."
        elif freq < 5:
            freq_note = "User trainiert 3-4x pro Woche - 3er oder 4er Split empfohlen."
        else:
            freq_note = "User trainiert h√§ufig - 5er Split oder PPL m√∂glich."
        
        # Push/Pull Balance
        balance = analysis_data['push_pull_balance']
        balance_note = "‚úÖ Balanced" if balance['balanced'] else f"‚ö†Ô∏è Unbalanced (Ratio: {balance['ratio']})"
        
        # Top 5 Muskelgruppen nach Volumen
        mg_sorted = sorted(
            analysis_data['muscle_groups'].items(),
            key=lambda x: x[1]['effective_reps'],
            reverse=True
        )[:5]
        top_muscles = ", ".join([f"{mg} ({int(data['effective_reps'])} eff.Wdh)" for mg, data in mg_sorted])
        
        # Schwachstellen
        weaknesses_str = "\n".join([f"  - {w}" for w in analysis_data['weaknesses'][:5]])
        
        # Few-shot examples mit EXAKTEN Namen aus der Liste
        example_exercises = [ex for ex in available_exercises if any(kw in ex for kw in ['Bankdr√ºcken', 'Kniebeuge', 'Kreuzheben'])][:3]
        examples_str = "\n".join([f'  "{ex}"' for ex in example_exercises])
        
        prompt = f"""**TRAININGSANALYSE**

**User ID:** {analysis_data['user_id']}
**Analysezeitraum:** {analysis_data['analysis_period']}

**Trainingsfrequenz:**
- Sessions gesamt: {analysis_data['training_stats']['total_sessions']}
- Pro Woche: {freq}x
- Durchschnitt: {analysis_data['training_stats']['avg_duration_minutes']} Minuten
{freq_note}

**Muskelgruppen (Top 5 nach Volumen):**
{top_muscles}

**Push/Pull Balance:**
- Push: {balance['push_volume']} | Pull: {balance['pull_volume']}
- Ratio: {balance['ratio']} - {balance_note}

**Schwachstellen:**
{weaknesses_str}

**VERF√úGBARE √úBUNGEN ({len(available_exercises)}):**
** WICHTIG:** Verwende die Namen **EXAKT** wie unten aufgelistet - KEIN Umformulieren!

Beispiele f√ºr KORREKTE Namen (kopiere exakt so):
{examples_str}

**VOLLST√ÑNDIGE LISTE** (w√§hle aus diesen):
{chr(10).join([f"  - {ex}" for ex in sorted(available_exercises)])}

** NOCHMAL: Kopiere die "exercise_name" Werte EXAKT aus der Liste oben!**
Beispiel: Wenn du "Kniebeuge (Langhantel, Back Squat)" verwenden willst, schreibe EXAKT:
  "exercise_name": "Kniebeuge (Langhantel, Back Squat)"

NICHT schreiben: "Langhantel Kniebeuge", "Back Squat", oder andere Variationen!

**AUFGABE:**
{instruction}

**Anforderungen:**
1. Ber√ºcksichtige die Schwachstellen und priorisiere untertrainierte Muskelgruppen
2. Verwende NUR √úbungen aus der Liste verf√ºgbarer √úbungen
3. Achte auf Push/Pull Balance (bei Unbalance gegensteuern)
4. SATZ-BUDGET: {sets_per_session} S√§tze pro Trainingstag (ca. 1 Stunde Training)
   - Verteile die S√§tze auf 4-6 √úbungen
   - Z.B. bei 18 S√§tzen: 4 S√§tze (Haupt√ºbung) + 3+3+3+3+2 = 18 S√§tze total
5. Compound Movements (Langhantel-Kniebeuge, Bankdr√ºcken, Kreuzheben) priorisieren
6. RPE-Targets: 7-9 f√ºr Hypertrophie
7. ** KEINE DOPPELTEN √úBUNGEN**: Jede √úbung darf nur EINMAL im GESAMTEN Plan vorkommen (nicht in mehreren Sessions wiederholen)!
8. Output: Valides JSON wie im System Prompt beschrieben

Erstelle jetzt den optimalen Trainingsplan:"""
        
        return prompt
    
    def build_messages(
        self,
        analysis_data: Dict[str, Any],
        available_exercises: List[str],
        plan_type: str = "3er-split",
        sets_per_session: int = 18
    ) -> List[Dict[str, str]]:
        """Erstellt Ollama Messages Array (System + User)"""
        return [
            {"role": "system", "content": self.system_prompt},
            {"role": "user", "content": self.build_user_prompt(analysis_data, available_exercises, plan_type, sets_per_session)}
        ]
    
    def get_available_exercises_for_user(self, user_id: int) -> List[str]:
        """
        Holt alle √úbungen die der User mit seinem Equipment ausf√ºhren kann
        
        Args:
            user_id: User ID
        
        Returns:
            Liste der √úbungsnamen
        """
        from core.models import Uebung
        from django.contrib.auth.models import User
        
        user = User.objects.get(id=user_id)
        user_equipment_ids = set(user.verfuegbares_equipment.values_list('id', flat=True))
        
        available_exercises = []
        
        for uebung in Uebung.objects.prefetch_related('equipment'):
            required_eq_ids = set(uebung.equipment.values_list('id', flat=True))
            
            # √úbung ist verf√ºgbar wenn:
            # 1. Kein Equipment ben√∂tigt ODER
            # 2. Alle ben√∂tigten Equipment-Teile beim User vorhanden sind
            if not required_eq_ids or required_eq_ids.issubset(user_equipment_ids):
                available_exercises.append(uebung.bezeichnung)
        
        return sorted(available_exercises)


if __name__ == "__main__":
    # Test: Prompt Builder mit echten Daten
    import sys
    sys.path.insert(0, '..')
    
    from db_client import DatabaseClient
    from data_analyzer import TrainingAnalyzer
    
    print("=== Prompt Builder Test ===\n")
    
    try:
        with DatabaseClient() as db:
            # Daten analysieren
            analyzer = TrainingAnalyzer(user_id=1, days=30)
            analysis = analyzer.analyze()
            
            # Prompt Builder
            builder = PromptBuilder()
            
            # Verf√ºgbare √úbungen ermitteln
            print("üîç Ermittle verf√ºgbare √úbungen...")
            available_exercises = builder.get_available_exercises_for_user(user_id=1)
            print(f"   ‚úì {len(available_exercises)} √úbungen verf√ºgbar\n")
            
            # Messages erstellen
            messages = builder.build_messages(analysis, available_exercises, plan_type="3er-split")
            
            # System Prompt ausgeben (gek√ºrzt)
            print("üìã System Prompt:")
            print(messages[0]['content'][:300] + "...\n")
            
            # User Prompt ausgeben
            print("üìä User Prompt:")
            print(messages[1]['content'][:800] + "...\n")
            
            # Vollst√§ndige Messages f√ºr LLM
            print("‚úÖ Messages Array fertig f√ºr Ollama!")
            print(f"   - System Prompt: {len(messages[0]['content'])} Zeichen")
            print(f"   - User Prompt: {len(messages[1]['content'])} Zeichen")
    
    except Exception as e:
        print(f"\n‚ùå Fehler: {e}")
        import traceback
        traceback.print_exc()
